(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{85:function(t,a,s){"use strict";s.r(a);var r=s(0),i=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"home"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#home"}}),t._v(" "),s("router-link",{attrs:{to:"/"}},[t._v("Home")])],1),t._v(" "),s("h3",{attrs:{id:"modularization-webpack"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#modularization-webpack"}}),t._v(" "),s("a",{attrs:{href:"#Modularization"}},[t._v("Modularization")]),t._v(" "),s("a",{attrs:{href:"#Webpack"}},[t._v("Webpack")])]),t._v(" "),s("hr"),t._v(" "),s("h1",{attrs:{id:"modularization"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#modularization"}}),t._v(" Modularization")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("概念")]),t._v(" "),s("p",[t._v("把系统分成独立功能的方法，我们需要什么功能就去加载什么功能")])]),t._v(" "),s("h2",{attrs:{id:"模块化为我们解决了什么问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块化为我们解决了什么问题"}}),t._v(" 模块化为我们解决了什么问题")]),t._v(" "),s("div",{staticClass:"custom-block danger"},[s("p",{staticClass:"custom-block-title"},[t._v("1.命名冲突")]),t._v(" "),s("p",[t._v("当在开发一个项目时会发现变量越来越多，导致你自己都会忘记哪些变量名用过哪些没用过会很尴尬")])]),t._v(" "),s("div",{staticClass:"custom-block danger"},[s("p",{staticClass:"custom-block-title"},[t._v("2.文件依赖")]),t._v(" "),s("p",[t._v("甲负责开发A.js")]),t._v(" "),s("p",[t._v("乙负责开发B.js")]),t._v(" "),s("p",[t._v("当A中调用了B中的某一个变量，A又在B之前加载这时就会报错，造成排错困难（会让人以为你连JS的执行过程都不了解,就像吃了一个苍蝇一样的恶心啊)")])]),t._v(" "),s("h2",{attrs:{id:"我们为什么要使用模块化开发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#我们为什么要使用模块化开发"}}),t._v(" 我们为什么要使用模块化开发")]),t._v(" "),s("p",[t._v("除了解决上述两个问题外")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("提升")]),t._v(" "),s("p",[t._v("1.程序的可维护性")]),t._v(" "),s("p",[t._v("2.程序的可复用性")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("总结")]),t._v(" "),s("p",[t._v("这种开发方式生产效率高，思路清晰，职责明确，维护成本低。")])]),t._v(" "),s("h1",{attrs:{id:"过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#过程"}}),t._v(" 过程")]),t._v(" "),s("h2",{attrs:{id:"第一阶段：初级阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第一阶段：初级阶段"}}),t._v(" 第一阶段：初级阶段")]),t._v(" "),s("h3",{attrs:{id:"全局函数：把重复的代码封装到函数中，再将一些列的函数放入到一个文件中"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#全局函数：把重复的代码封装到函数中，再将一些列的函数放入到一个文件中"}}),t._v(" 全局函数：把重复的代码封装到函数中，再将一些列的函数放入到一个文件中")]),t._v(" "),s("ul",[s("li",[t._v("1.污染全局变量")]),t._v(" "),s("li",[t._v("2.看不出相互之间直接的关系")])]),t._v(" "),s("h2",{attrs:{id:"第二阶段：面向对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第二阶段：面向对象"}}),t._v(" 第二阶段：面向对象")]),t._v(" "),s("h3",{attrs:{id:"对象命名空间：就是使用对象的属性来扩展"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象命名空间：就是使用对象的属性来扩展"}}),t._v(" 对象命名空间：就是使用对象的属性来扩展")]),t._v(" "),s("ul",[s("li",[t._v("问题1：从某种程度上是解决了变量命名冲突。但并没有从根本上解决命名冲突")]),t._v(" "),s("li",[t._v("问题2：命名空间越来越长")]),t._v(" "),s("li",[t._v("问题3：内部状态可以被外部改写")])]),t._v(" "),s("h2",{attrs:{id:"第三阶段-私有公有"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第三阶段-私有公有"}}),t._v(" 第三阶段: 私有公有")]),t._v(" "),s("h3",{attrs:{id:"严格的说js中不存在真真意义上的私有变量，所谓私有是一种表示，它依赖于不同开发者之间的共识“-count”。但由于js的函数作用域特性，其实可以认为，任何在函数中定义的变量，都可以认为是私有变量，因为在函数外部不能访问到这些变量，只有在函数本身内部，或者内部闭包函数里才能访问这些变量。此时便可以将私有变量放在一个函数里，然后以闭包的形式，在该函数里创建特权函数来访问和操纵这些变量。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#严格的说js中不存在真真意义上的私有变量，所谓私有是一种表示，它依赖于不同开发者之间的共识“-count”。但由于js的函数作用域特性，其实可以认为，任何在函数中定义的变量，都可以认为是私有变量，因为在函数外部不能访问到这些变量，只有在函数本身内部，或者内部闭包函数里才能访问这些变量。此时便可以将私有变量放在一个函数里，然后以闭包的形式，在该函数里创建特权函数来访问和操纵这些变量。"}}),t._v(" 严格的说JS中不存在真真意义上的私有变量，所谓私有是一种表示，它依赖于不同开发者之间的共识“_count”。但由于js的函数作用域特性，其实可以认为，任何在函数中定义的变量，都可以认为是私有变量，因为在函数外部不能访问到这些变量，只有在函数本身内部，或者内部闭包函数里才能访问这些变量。此时便可以将私有变量放在一个函数里，然后以闭包的形式，在该函数里创建特权函数来访问和操纵这些变量。")]),t._v(" "),s("h3",{attrs:{id:"虽然解决了变量命名冲突的问题，但是没有解决开发复杂程度问题。如果不是使用静态私有变量特权法还会占用大量的内存空间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虽然解决了变量命名冲突的问题，但是没有解决开发复杂程度问题。如果不是使用静态私有变量特权法还会占用大量的内存空间"}}),t._v(" 虽然解决了变量命名冲突的问题，但是没有解决开发复杂程度问题。如果不是使用静态私有变量特权法还会占用大量的内存空间")]),t._v(" "),s("h2",{attrs:{id:"目前阶段：模块化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#目前阶段：模块化"}}),t._v(" 目前阶段：模块化")]),t._v(" "),s("h3",{attrs:{id:"模块化概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块化概念"}}),t._v(" 模块化概念")]),t._v(" "),s("h3",{attrs:{id:"目前模块化的一些标准和规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#目前模块化的一些标准和规范"}}),t._v(" 目前模块化的一些标准和规范")]),t._v(" "),s("h4",{attrs:{id:"待续"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#待续"}}),t._v(" 待续...")])])}),[],!1,null,null,null);a.default=i.exports}}]);